# leetcode note

* 1. PowerOfTwo:（3）
   1)本身就是返回布尔，直接return即可 return x == 1
   2)2 ^ n = x  ==> n是整数的话x就是power of two.算出n的方法为 log2（x）
   3)判断n是否整数的方法：return （r | 0）== r => 所有的数参与位运算自动会转成整数， 跟0做或运算返回本身。注意加括号
   4) 所以除于2后得到整数的方法：改写成右位移1位， 注意如果数字过大超过2的31次方-1 即2147483647 保留符号位的位移就不再准确了2041483647再右移一位就变成负数-2147483648。如果只考虑正数用三个>>>，不保留符号位的右移
      x = (x >> 1) 可写成 x >>= 1
   5)2的n次方转二进制除了最左边第一位是1其它都是0
   6)与n-1的二进制做 与运算 结果为0的话能证明是2的n次方的数
 （1）除于2除到1为止就是2的n次方的数 -->优化：能被2整除的数字就用位移整除
 （2）log2（x）判断是否整数
 （3）判断二进制数除了第一位全是0的方法：与n-1做与运算结果是否0

 * 2. PowerOfFour：（2）
  1)4^n = 2^2n = 100000000 后面总是有偶是个零
  2）二进制数是不是包含偶数个零验证方法：与1010101010... 32位（magic number）做与运算结果是否为0-》转换成16进制变成8个a -》防溢出0x2aaaaaaa
（1）整除4到1
（2）先验证是否除了第一位全是0，而且是个偶数个零

* 3. PowerOfThree：（2）
  1) 3的n次方是只由一个因子相乘得出来的数：3*3*3*3*3*3*3 / 3*3*3*3 ==>这种形式结果才为整数
  2）取电脑能存最大的3的n次方的数：math.log(2147483647)/math.log(3) = 19.558...
  3）3^19 = 1162261467 % n == 0
 (1)整除3到1
（2）1162261467 % n == 0

* 4. hammingDistance：（3）
  1） 循环条件：x,y两个数全部要循环到0,也就是两个数都变成0就结束循环：while(x !== 0 || y !==0)
  2） 两个数字转成2进制之后把所有不同的部分标明出来的方法：异或运算后数1的个数（z >>= 1）
  3） 任何数n与自己n-1 做按位与运算 倒数第一个1就会变成0
（1）转为二进制后比较，不同的时候count++
（2）异或运算
（3）快速读取二进制里的1的方法，跟n-1与运算的次数，运算到0为止

* 5. Ugly-Number：（2）
  1）质因子只有2，3，5的数：(2^31 * 3^19 * 5^13) % number ==0
  2）先除2除到除不尽，再往下除3到除不尽，再往下除5到除不尽

* 6. powx-n：（4）
  1）n转换成2进制后，只要把对应于1的x^i相乘就等于powx-n
  2)n^100 ->n^50 * n^50 -> n^50 * n^25 * n^25 -> n^50 * n^25 * n^12 * n^12 * n-...本来要运算100次如果这么算只算9次即可
  3)取一个数字的二进制的宽度的方法1：Math.floor(Math.log2(n))
                            方法2：每次右移1位，count++。 直到数变成0 
                            注意：2147483648>>1就变成-2147483647，所以要用不保留符号位的>>>。这个只能用在只考虑正数的时候
  4)2进制数从左往右取值的方法：n>>width （width--）
  5)判断最后一位是1还是0的方法，对2取余，如果是1就是1，如果不是就是0
（1）n转2进制，每逢1就乘；前一位的x的平方等于后一位的x的原理；n的二进制数来说方向是从右往左 --最优化
（2）n除于2的过程中每遇到偶数就是计算后一个数乘后一个数， 遇到奇数后一个数乘上后一个数再乘上n .n的二进制数来说方向是从右往左， 递归
（3）n先求2进制的宽度，再通过位移从左往右遇到奇数就是t*t*x  偶是 t*t；变量t。传递每次计算的结果，用来下一次再利用。 t的初始值设定为1
（4）跟（3）一样，取1进制宽度的方法改成位移

* 7. addDigits（1）
    the process is like: 3 + 8 = 11, 1 + 1 = 2.
   1)公式：1935 % 9 = （1+9+3+5）%9
   * =》（1*1000 + 9*100 + 3 * 10 + 5 ）% 9=>(1*(1+999) + 9*(1+99) + 3*(1+9) + 5)%9(因为1000取余9剩下1)
   * =>(1+9+3+5)%9
   * 所以num假如38：38%9=（3+8）%9 = (11)%9 = (2)%9=2)

* 8. mySqr（2）
  (1） *牛顿法：x1=x0-f(x0)/f'(x0)  ； 求平方根的f(x)=x^2 - n=0 ==> x=saqrt(n) ->代入公式得：x1 = x0 - (x0 ^2 - n)/(2*x0)
  (2)  二分法：每次算出中间值比较，如果中间值比目的值小，需要在右范围查找，就把中间值赋给low值，如果更大把中间值赋给high值
* 如果high和low的差值等于1，就把low值return即可

* 9. countPrimes（5）
  1)“埃拉托斯特尼筛”:1不是质数，也不是合数，要划去。第二个数2是质数留下来，而把2后面所有能被2整除的数都划去。2后面第一个没划去的数是3，把*3留下，再把3后面所有能被3整除的数都划去。3后面第一个没划去的数是5，把5留下，再把5后面所有能被5整除的数都划去。这样一直做下去
  2)sqrt(n)之前的数的倍数已经能够把所有n为止的和数划掉了；所以划的因子数到sqrt（n）即可
  3）每个数能最快划掉的是自己的平方；比如3划掉自己的倍数的时候第一个是9，因为之前的6已经被2划掉了，所以划相应倍数的时候从平方开始
  4）奇数的话，划数的周期为自己的2倍。 比如 3 下面是 9 再下面是 15 .。。 周期是6 ；所以划掉的周期奇数可写自己的2倍
  5）可简化
    // if(j % 2 !== 0){
    //   var step = k * 2
    // }else{
    //   step = k
    // }
    var step = j % 2? k * 2 : k
  6）可简化
     //flags[c] == 1
     //count++
      count += flags[c]
（1）制作一个isPrime函数（判断方法：把要认证的数n从2除到根号n），遍历每一个n为止的数。
 (2) 制作primeList ，不用每次都从2开始++，而只要把primelist里的质数除一下就能知道是不是质数. 
     因为是按照顺序每次都是从小到大排序的才可行：比如2进去判定的时候因为primeList是undefined，肯定会判定成true，之后放进primeList。
     3进去被前面的2除不了又放进primeList，4进去被2可除，就不放进去。。。以此类推，每次除到primeList[i]等于根号n为止
（3）primeList为全局变量，判定系统每次调用都不会重置0，把之前的数全部累加。 要把primeList转成局部变量，每次整个function开始之前清空
（4）primeList每判断新的数字都会从2开始push进去，优化：变回全局变量，以及if(n > primeList[primeList.length - 1]) primeList.push(n)
（5）埃拉托斯特尼筛：先制作一个全部都是1的长度为n的数组，后面按顺序把不是质数的划掉变成0，全部划完之后记1有几个
     核心带吗； for(var j = 2 ; j <= sqrt ; j++){                -->划的因子数到sqrt（n）即可
                      var step = j % 2? k * 2 : k               -->划掉的周期奇数可写自己的2倍
                      for(var k = j * j ; k < n ; k += step){   -->每个数能最快划掉的是自己的平方
                        flags[k] = 0
                      }
                    }

* 10. singleNumber:(2)
     1) 按位异或
        * 规律一：交换律：a ^ b^ c^ a^b = a^a^b^b^c
        * 规律二：自己跟自己异或 0
        * 规律三：跟0异或等于自身
    （1）遍历nums，用空的数组存nums里之前没出现过的值，之前出现过的就删掉。最后只剩下只出现过一次的数字
         核心代码：if(arr.indexOf(nums[i]) != -1) arr.splice(idx,1)
     (2)从前到后一个个按位异或，输出结果

* 11. missing number（2）
    1）按顺序排序的数组里寻找特定的数
       方法1：可以用全是0的空数组，以及空数组的下标一一对应来寻找
       方法2：本该数求和 - 现有数求和 = 要找的数  
  （1）制作空数组全是0，跟数组里的数字对应的下标位置的数改成1
  （2）等差数列求和：n*(n+1)/2，再减去现有的所有数之和
   简洁方法：不用单独求和，直接在本该和一个个减去即可

* 12. moveZeroes（2）
   1）遍历当中如果需要splice就得i--的原因：splice后后面的全部移动到前面，如果不减中间的数就不可能被遍历到
   2）数组重新排列的题可用双指针
 （1）遍历所有数字遇到0就先删除，最后补上0
      注意：不能在遍历时边减0，边加0.因为会死循环。 
  (2) 双指针- 一个指针从左往右把每一个数字指一遍， 另外一个指针专门指不是0的数。 之后把第二个指针的数一一排列到第一个指针的位置上,遍历结束后从oZeroPointer后的位置开始放0
    
* 13. plusOne(1)
  (1)逻辑要清晰：最后一位加1，加一次即可。 加完之后遍历每位，如果大于9就变成0，前面的数加1。 直到遇到不是大于9的数就直接返回。 考虑边界情况：最前面是10就得，把数变成0，前面加1。

* 14. twoSum(2)
  Input: numbers = [2,7,11,15], target = 9   Output: [1,2] 
  (1)一个个遍历直到找到目标值为止， 可是时间限制过不去
  (2) 双指针：一个指针从头开始指，第二个指针从尾开始。 两个值相加，如果小了就把第一个指针往右移，如果大了第二个指针往左移，。

* 15. findMaxConsecutiveOnes(1)
   寻找连续出现的长度最大的方法
  (1)只循环一次的方法：每次maxcount遇到更大的数就更新一下

* 16. merge storted array(1)
 Input:nums1 = [1,2,3,0,0,0], m = 3     nums2 = [2,5,6],       n = 3
 Output: [1,2,2,3,5,6]
 (1) *思路：数组排序可用双指针。两组数组都是从小到大排序的，按顺序合并，需要从大比较小，把更大的先挑出来逐步放在最后面。
   *边界条件：两组数组其中任何一组先到达尽头，把剩下的数组全部按顺序填充剩下的位置即可

* 17. searchInsert position(1)
Input: [1,3,5,6], 7     Output: 4    Input: [1,3,5,6], 5     Output: 2
  (1)排序一般用二分法。指针问题想好边界条件
     边界条件：两个指针相差1的时候按照具体情况输出

* 18. countBits(3)
输入一个数，从0开始到那个数，每个数的2进制里的1的个数
Input: 5     Output: [0,1,1,2,1,2]
1) 二进制每逢2的n次方对比2的n-1次方多一个0，就像10进制每逢100，1000，多一个0一样。所以数字二进制宽度增加的固定周期就是2的n次方，也就是2*2*2*2... period *= 2  
2)每个数的二进制的1的个数等于减去临近2^n的十进制数的二进制的1的个数再加上1 ， 也就是说数的二进制下把最左边的1抹掉，最后再加上1
3)反推：想要抹掉数字的二进制下的最左边的1，就要减去临近的2的n次方. 判断最邻近的2的n次方的方法： if(i == 2 * period){period *= 2}
4)因为2的时候没有相应周期规律，应当特殊处理。 再然后因为每次2的n次方总是只有1个1，故直接全部特殊处理
(1) 每个数字变成2进制再把1的个数组合进去新数组里
(2) 二进制下把最左边的1抹掉，最后再加上1
核心代码： if(i == 2 * period){result[i] = 1;period *= 2
      }else{result[i] = result[i - period] + 1 }     
(3)查询从0到n的二进制数的前后两个数的规律。 n和n-1每次做按位与运算，就会少一个最右边的一个1
思路：根据与前一个数的关系，先把二进制的最右边的1减去，最后加上1就等于本身的1的个数:核心代码：result[i] = result[ i & (i - 1)] + 1 


* 19. 两个二进制相加Input: a = "1010", b = "1011"   Output: "10101"(1)
 (1)stringToArray的放法:s.split('') ,如果参与运算直接转换成Numberi再组合


* 20. reverseBits(1)
  (1)像十进制一样，每对2取余，找到最后一位数，重新组合，就把之前的数乘2再加这次的余数， 每次n减去余数后再除于2，抹掉最后一位后再加入循环
   2）-1 >>> 0 负数当成无符号数
   3） 从右往左获取二进制下的每一位数的方法：d=(n >>> i) & 1
   注意：10000...1 负数加上1 ，出来了还是100000010负数。需要转换成无符号整数 sum >>> 0

* 21. 计算星期（2）
 （1）从公元1年开始累加所有的天数，根据已知的天的星期，调试（day+1）再模7.
 （2）计算从公元1年到n-1年的天数的方法：
  day = 365 * (y -1) + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor( y / 400)


* 22. Sum of Square Numbers(1)
Input: 5     Output: True    Explanation: 1 * 1 + 2 * 2 = 5
  1)不用用数组重新组成0到根号n的数，因为指针本身就是有序增加的，直接用指针表示0到n的数即可
  2）完全平方数，只要找到一个数即可的，跟0的平方和就是本身，所以不要从1开始遍历，而是从0遍历到根号n
（1）用双指针，小了就把右指针往左，大了就把左指针往右，直到两个指针相差 0 .

* 23. hammingWeight （1）
 (1)读取某个数的二进制里的1的个数的方法:
    方法1：与1做按位与运算
    方法2：与（n-1）做按位与运算
（2）如果传二进制数，直接在前面加0b。如果是字符串直接用引号包着传进来

* 24. Minimum Moves to Equal Array Elements (1)
(1)逆转思维：题目说每一步要增加， 转换成全部元素退化到最小需要几步

* 25. valid-parentheses(1)
(1) 思路：先进后出，栈

* 26. minimum-moves-to-equal-array-elements-ii(2)
(1)找到中间值，取差值
(2)   最前面的数和最后面的数相减= 他俩到中间的总和   每一对的数相加  联想聚餐取点

* 27. Triangle(2)
(1) 递归，有很多重复计算，需要用cache缓存
（2）逆转思维：从上往下想成从下往上


* 28. Delete Node in a Linked List
链表无法删除目前的节点， 因为无法访问前面的节点。
只能通过跟下一个节点换值后，把下一个节点删掉。


* 29. Remove Linked List Elements
  /* 
  用遍历的方法的话需要注意以下几点：
  开头：如果第一个就是要删除的点，就得把head本身也往后走，最后输出点确定.
  之后再把head传给另外一个变量来遍历
  空链表：如果是空链表 head.val 就是错误的， 所以head.val条件加上head本身有值
  结尾：如果光是head.next为true的时候才能进循环的话，head本身是空链表的话就直接报错
  中间：如果要删除的数字连续在一起，就删不掉后面的(1,2,2,1)删掉2，所以每次删除之后先不要往前走
  链表用递归：一半都会分成两个部分再次进入循环
  此题分为第一个节点和其它节点两个部分进入循环
   */


* 30.  Remove Nth Node From End of List

（1） 找到链表的倒数第n个节点的方法：
  1）递归到最底层，收回来的时候开始数数，数到等于n时把数字去掉即可(因为要再往前走后才能删除点需要count等于n+1)
  问题是：如果是第一个节点就无法用这个方法删除，需要标记一下。 如果进入了if循环就说明之前已经改掉了，如果没进入循环就说明要删除第一个节点
  2）遍历一次的方法：
  两个指针相隔n,之后同步移动。 最后右面的到达最深处后，左边的指针就是那个位置，


  * 31. Merge Two Sorted Lists

     if(l1 && !l2){
     return l1
   }
    if(!l1 && l2){
     return l2
   }

   以上可简化成 if(!l1 || !l2){return l1 || l2}


   * 32. Sort List
   1)把一个链表差分为二的方法（归并做法）： 用两个指针一个走一步，另一个每次走两步
   注意： 只有两个节点的时候会无穷循环， 所以前面加dummy节点，就算是两个也能正常拆分
   每次确保fast正确能执行的循环条件： while(fast && fast.next)
   2）一个空链表或者只有一个节点的链表返回本身的写法： if(!head || !head.next){return head}


   * 33. 数组的冒泡排序
    冒泡排序可优化以下两点： 1）每次循环可逐步减少1次， 因为每次循环已经把最大的放到最边上了， 
                            2）如果有一次一个都没被调换就说明已经排好了，没必要继续，可中间直接break  